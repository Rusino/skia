/*
 * Copyright 2019 Google Inc.
 *
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

#include "SkTextWrapper.h"
#include "SkParagraphImpl.h"

bool SkTextWrapper::addLine(Position& pos) {
  if (pos.trimmedWidth() == 0 && !pos.end()->isHardBreak()) {
    // Ignore an empty line if it's not generated by hard line break
    pos.clean(pos.end());
    return true;
  }

  // TODO: Set the ellipsis direction accordingly to text direction... or text alignment?..
  auto& line = fParent->addLine(
    SkVector::Make(0, fCurrentLineOffset.fY), // offset
    SkVector::Make(pos.trimmedWidth(), pos.height()), // advance
    pos.trimmedText(fLineStart), // text
    pos.sizes()); // metrics

  line.reorderRuns();

  if (fParent->reachedLinesLimit(0) && pos.end() != fClusters.end() - 1 && !fEllipsis.empty()) {
    // We must be on the last line and not at the end of the text
    line.createEllipsis(fMaxWidth, fEllipsis, true);
  }

  fWidth =  SkMaxScalar(fWidth, pos.trimmedWidth());
  fHeight += pos.height();

  fLineStart = pos.end() + 1;
  if (!pos.end()->isHardBreak()) {
    while (fLineStart < fClusters.end() &&
        fLineStart->isWhitespaces()) { fLineStart += 1; }
  }
  fCurrentLineOffset.fY += pos.height();
  pos.clean(fLineStart);
  return !fParent->reachedLinesLimit(0);
}

void SkTextWrapper::formatText(SkSpan<SkCluster> clusters,
                               SkScalar maxWidth,
                               size_t maxLines,
                               const std::string& ellipsis) {
  fClusters = clusters;
  fMaxWidth = maxWidth;
  fEllipsis = ellipsis;
  fLineStart = fClusters.begin();
  fClosestBreak.clean(fLineStart);
  fAfterBreak.clean(fLineStart);
  fCurrentLineOffset = SkVector::Make(0, 0);
  fWidth = 0;
  fHeight = 0;
  fMinIntrinsicWidth = 0;

  // Iterate through all the clusters in the text
  SkScalar wordLength = 0;
  for (auto& cluster : clusters) {
    if (!cluster.isWhitespaces()) {
      wordLength += cluster.fWidth;
      if (fClosestBreak.width() + fAfterBreak.width() + cluster.fWidth > fMaxWidth) {
        // Cluster does not fit: add the line until the closest break
        if (!addLine(fClosestBreak)) break;
      }
      if (fAfterBreak.width() + cluster.fWidth > fMaxWidth) {
        // Cluster does not fit yet: try to break the text by hyphen
        // TODO: This is the place where we add the hypenation logic
      }

      if (fAfterBreak.width() + cluster.fWidth > fMaxWidth) {
        // Cluster does not fit yet: add the line with the rest of clusters
        SkASSERT(fClosestBreak.width() == 0);
        fClosestBreak.add(fAfterBreak);
        if (!addLine(fClosestBreak)) break;
      }
      if (cluster.fWidth > fMaxWidth) {
        //  Cluster still does not fit: it's too long; let's clip it
        fClosestBreak.add(cluster);
        if (!addLine(fClosestBreak)) break;
        continue;
      }
    } else {
      fMinIntrinsicWidth = SkTMax(fMinIntrinsicWidth, wordLength);
      wordLength = 0;
    }
    // The cluster fits the line
    fAfterBreak.add(cluster);

    if (cluster.canBreakLineAfter()) {
      fClosestBreak.add(fAfterBreak);
    }
    if (cluster.isHardBreak()) {
      // Hard line break
      if (!addLine(fClosestBreak)) break;
    }
  };
  // Make sure nothing left
  if (!endOfText() && !fParent->reachedLinesLimit(0)) {
    fMinIntrinsicWidth = SkTMax(fMinIntrinsicWidth, wordLength);
    fClosestBreak.add(fAfterBreak);
    addLine(fClosestBreak);
  }
}
