/*
 * Copyright 2019 Google Inc.
 *
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

#include "SkTextWrapper.h"
#include "SkParagraphImpl.h"

bool SkTextWrapper::addLineUpToTheLastBreak() {
    if (fLastSoftLineBreak.width() == 0 && !fLastSoftLineBreak.end()->isHardBreak()) {
        // Ignore an empty line if it's not generated by hard line break
        fLastSoftLineBreak.clean(fLastSoftLineBreak.end());
        return true;
    }

    if (fParent->strutEnabled()) {
        // Make sure font metrics are not less than the strut
        fParent->strutMetrics().updateLineMetrics(fLastSoftLineBreak.sizes(),
                                                  fParent->strutForceHeight());
    }

    auto& line = fParent->addLine(
            SkVector::Make(0, fOffsetY),  // offset
            SkVector::Make(fLastSoftLineBreak.trimmedWidth(),
                           fLastSoftLineBreak.height()),  // advance
            fLastSoftLineBreak.trimmedText(fLineStart),   // text
            SkSpan<const SkCluster>(fLineStart, fLastSoftLineBreak.trimmed() - fLineStart + 1),
            SkSpan<const SkCluster>(fLastSoftLineBreak.end(),
                                    fLastSoftLineBreak.end() - fLastSoftLineBreak.trimmed() + 1),
            fLastSoftLineBreak.sizes());  // metrics
    ++fLineNumber;

    if (reachedLinesLimit() && fLastSoftLineBreak.end() != fClusters.end() - 1 &&
        !fEllipsisText.empty()) {
        // We reached the line limit but not the end of the text
        line.createEllipsis(fMaxWidth, fEllipsisText, true);
    } else {
        fLineStart = fLastSoftLineBreak.end() + 1;
        if (!fLastSoftLineBreak.end()->isHardBreak()) {
            // For the next line skip the spaces at the beginning of the line
            // if there was no hard line break before
            while (fLineStart < fClusters.end() && fLineStart->isWhitespaces()) {
                fLineStart += 1;
            }
        }
    }

    fWidth = SkMaxScalar(fWidth, fLastSoftLineBreak.trimmedWidth());
    fHeight += fLastSoftLineBreak.height();
    fOffsetY += fLastSoftLineBreak.height();
    fLastSoftLineBreak.clean(fLineStart);

    return !reachedLinesLimit();
}

SkScalar SkTextWrapper::lengthUntilSoftLineBreak(SkCluster* cluster) {
    SkScalar length = 0;
    SkCluster* current = cluster;
    while (current != fClusters.end()) {
        if (current->canBreakLineAfter()) {
            break;
        }
        length += cluster->width();
        ++current;
    }
    return length;
}

void SkTextWrapper::formatText(SkSpan<SkCluster> clusters,
                               SkScalar maxWidth,
                               size_t maxLines,
                               const std::string& ellipsis) {
    // Set up the wrapper
    fClusters = clusters;
    fMaxWidth = maxWidth;
    fEllipsisText = ellipsis;
    fLineStart = fClusters.begin();
    fLastSoftLineBreak.clean(fLineStart);
    fLastClusterBreak.clean(fLineStart);
    fOffsetY = 0;
    fWidth = 0;
    fHeight = 0;
    fMinIntrinsicWidth = 0;
    fLineNumber = 0;
    fMaxLines = maxLines;

    // Iterate through all the clusters in the text (in order of input text)
    SkScalar wordLength = 0;
    for (auto& cluster : clusters) {
        if (!cluster.isWhitespaces()) {
            wordLength += cluster.width();
            if (fLastSoftLineBreak.width() + fLastClusterBreak.width() + cluster.trimmedWidth() >
                fMaxWidth) {
                // There is one tricky case of too-long-word that does not fit a line anyway
                // but since we don't know it in advance we break the line before this too-long-word
                // and potentially cause an unnecessary line break; to avoid this situation
                // we need to look ahead
                auto length = fLastClusterBreak.width() + lengthUntilSoftLineBreak(&cluster);
                if (length > maxWidth) {
                    // We cannot fit the word on the line anyway;
                    // let's break it in the middle and hope is' enough
                    fLastSoftLineBreak.moveTo(fLastClusterBreak);
                }
                // Cluster does not fit: add the line until the closest break
                if (!addLineUpToTheLastBreak()) break;
            }

            if (fLastClusterBreak.width() + cluster.trimmedWidth() > fMaxWidth) {
                // Cluster does not fit yet: add the line with the rest of clusters
                // (this is an emergency break)
                SkASSERT(fLastSoftLineBreak.width() == 0);
                fLastSoftLineBreak.moveTo(fLastClusterBreak);
                if (!addLineUpToTheLastBreak()) break;
            }

            if (cluster.trimmedWidth() > fMaxWidth) {
                // Cluster still does not fit: it's too long
                // (we are past emergency break; let's clip it)
                fLastSoftLineBreak.moveTo(cluster);
                if (!addLineUpToTheLastBreak()) break;
                continue;
            }
        } else {
            fMinIntrinsicWidth = SkTMax(fMinIntrinsicWidth, wordLength);
            wordLength = 0;
        }
        // The cluster fits the line
        fLastClusterBreak.moveTo(cluster);

        if (cluster.canBreakLineAfter()) {
            fLastSoftLineBreak.moveTo(fLastClusterBreak);
        }
        if (cluster.isHardBreak()) {
            if (!addLineUpToTheLastBreak()) break;
            if (endOfText()) {
                fLineStart = &cluster;
                fLastSoftLineBreak.clean(&cluster);
                fLastSoftLineBreak.moveTo(cluster);
                addLineUpToTheLastBreak();
            }
        }
    };
    // Make sure nothing left
    if (!endOfText() && !reachedLinesLimit()) {
        fMinIntrinsicWidth = SkTMax(fMinIntrinsicWidth, wordLength);
        fLastSoftLineBreak.moveTo(fLastClusterBreak);
        addLineUpToTheLastBreak();
    }
}
