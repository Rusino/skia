/*
 * Copyright 2019 Google Inc.
 *
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

#include "SkTextWrapper.h"
#include "SkParagraphImpl.h"

bool SkTextWrapper::addLineUpToTheLastBreak() {

  if (fLastSoftLineBreak.width() == 0 && !fLastSoftLineBreak.end()->isHardBreak()) {
    // Ignore an empty line if it's not generated by hard line break
    fLastSoftLineBreak.clean(fLastSoftLineBreak.end());
    return true;
  }

  if (fParent->strutEnabled()) {
    // Make sure font metrics are not less than the strut
    fParent->strutMetrics().updateLineMetrics(fLastSoftLineBreak.sizes(), fParent->strutForceHeight());
  }

  auto& line = fParent->addLine(
    SkVector::Make(0, fOffsetY), // offset
    SkVector::Make(fLastSoftLineBreak.trimmedWidth(), fLastSoftLineBreak.height()), // advance
    fLastSoftLineBreak.trimmedText(fLineStart), // text
    SkSpan<const SkCluster>(fLineStart, fLastSoftLineBreak.trimmed() - fLineStart + 1),
    SkSpan<const SkCluster>(fLastSoftLineBreak.end(), fLastSoftLineBreak.end() - fLastSoftLineBreak.trimmed() + 1),
    fLastSoftLineBreak.sizes()); // metrics
  ++fLineNumber;

  if (reachedLinesLimit() && fLastSoftLineBreak.end() != fClusters.end() - 1 && !fEllipsisText.empty()) {
    // We reached the line limit but not the end of the text
    line.createEllipsis(fMaxWidth, fEllipsisText, true);
  } else {
    fLineStart = fLastSoftLineBreak.end() + 1;
    if (!fLastSoftLineBreak.end()->isHardBreak()) {
      // For the next line skip the spaces at the beginning of the line
      // if there was no hard line break before
      while (fLineStart < fClusters.end() &&
          fLineStart->isWhitespaces()) { fLineStart += 1; }
    }
  }

  fWidth =  SkMaxScalar(fWidth, fLastSoftLineBreak.trimmedWidth());
  fHeight += fLastSoftLineBreak.height();
  fOffsetY += fLastSoftLineBreak.height();
  fLastSoftLineBreak.clean(fLineStart);

  return !reachedLinesLimit();
}

SkScalar SkTextWrapper::lengthUntilSoftLineBreak(SkCluster* cluster) {
  SkScalar length = 0;
  SkCluster* current = cluster;
  while (current != fClusters.end()) {
    if (current->canBreakLineAfter()) {
      break;
    }
    length += cluster->width();
    ++current;
  }
  return length;
}

void SkTextWrapper::formatText(SkSpan<SkCluster> clusters,
                               SkScalar maxWidth,
                               size_t maxLines,
                               const std::string& ellipsis) {
  // Set up the wrapper
  fClusters = clusters;
  fMaxWidth = maxWidth;
  fEllipsisText = ellipsis;
  fLineStart = fClusters.begin();
  fLastSoftLineBreak.clean(fLineStart);
  fLastClusterBreak.clean(fLineStart);
  fOffsetY = 0;
  fWidth = 0;
  fHeight = 0;
  fMinIntrinsicWidth = 0;
  fLineNumber = 0;
  fMaxLines = maxLines;

  // Iterate through all the clusters in the text (in order of input text)
  SkScalar wordLength = 0;
  for (auto& cluster : clusters) {

    if (!cluster.isWhitespaces()) {
      wordLength += cluster.width();
      if (fLastSoftLineBreak.width() + fLastClusterBreak.width() + cluster.trimmedWidth() > fMaxWidth) {
        // There is one tricky case of too-long-word that does not fit a line anyway
        // but since we don't know it in advance we break the line before this too-long-word
        // and potentially cause an unnecessary line break; to avoid this situation
        // we need to look ahead
        auto length = fLastClusterBreak.width() + lengthUntilSoftLineBreak(&cluster);
        if (length > maxWidth) {
          // We cannot fit the word on the line anyway;
          // let's break it in the middle and hope is' enough
          fLastSoftLineBreak.moveTo(fLastClusterBreak);
        }
        // Cluster does not fit: add the line until the closest break
        if (!addLineUpToTheLastBreak()) break;
      }

      if (fLastClusterBreak.width() + cluster.trimmedWidth() > fMaxWidth) {
        // Cluster does not fit yet: add the line with the rest of clusters
        // (this is an emergency break)
        SkASSERT(fLastSoftLineBreak.width() == 0);
        fLastSoftLineBreak.moveTo(fLastClusterBreak);
        if (!addLineUpToTheLastBreak()) break;
      }

      if (cluster.trimmedWidth() > fMaxWidth) {
        // Cluster still does not fit: it's too long
        // (we are past emergency break; let's clip it)
        fLastSoftLineBreak.moveTo(cluster);
        if (!addLineUpToTheLastBreak()) break;
        continue;
      }
    } else {
      fMinIntrinsicWidth = SkTMax(fMinIntrinsicWidth, wordLength);
      wordLength = 0;
    }
    // The cluster fits the line
    fLastClusterBreak.moveTo(cluster);

    if (cluster.canBreakLineAfter()) {
      fLastSoftLineBreak.moveTo(fLastClusterBreak);
    }
    if (cluster.isHardBreak()) {
      if (!addLineUpToTheLastBreak()) break;
      if (endOfText()) {
        fLineStart = &cluster;
        fLastSoftLineBreak.clean(&cluster);
        fLastSoftLineBreak.moveTo(cluster);
        addLineUpToTheLastBreak();
      }
    }
  };
  // Make sure nothing left
  if (!endOfText() && !reachedLinesLimit()) {
    fMinIntrinsicWidth = SkTMax(fMinIntrinsicWidth, wordLength);
    fLastSoftLineBreak.moveTo(fLastClusterBreak);
    addLineUpToTheLastBreak();
  }
}
