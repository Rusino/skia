/*
 * Copyright 2019 Google Inc.
 *
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

#include "SkTextWrapper.h"
#include <stack>

namespace {
std::string toString(SkSpan<const char> text) {
  icu::UnicodeString
      utf16 = icu::UnicodeString(text.begin(), SkToS32(text.size()));
  std::string str;
  utf16.toUTF8String(str);
  return str;
}
}

SkRun* SkTextWrapper::createEllipsis(Position& pos) {
  if (!reachedLinesLimit(-1) || pos.end() == fClusters.end() - 1) {
    // We must be on the last line and not at the end of the text
    return nullptr;
  }
  if (fEllipsis.empty()) {
    return nullptr;
  }
  // Replace some clusters with the ellipsis
  auto lineEnd = pos.trimmed();
  while (lineEnd >= fLineGlyphStart) {
    // Calculate the ellipsis sizes for a given font
    SkRun* ellipsis = getEllipsis(lineEnd->fRun);
    if (pos.trimmedWidth() + ellipsis->advance().fX <= fMaxWidth) {
      // Ellipsis fit; place and size it correctly
      ellipsis->shift(-fCurrentLineOffset.fX + pos.trimmedWidth(),
                      lineEnd->fRun->sizes().diff(pos.sizes()));
      ellipsis->setHeight(pos.height());
      pos.extend(ellipsis->advance().fX);
      return ellipsis;
    }
    // It is possible that the ellipsis is wider than the line itself for a given font;
    // we still need to continue because we can find a smaller font and it will fit
    pos.extend(-lineEnd->fWidth);
    --lineEnd;
  }
  return nullptr;
}

bool SkTextWrapper::addLine(Position& pos) {
  if (pos.trimmedWidth() == 0 && !pos.end()->isHardBreak()) {
    // Ignore an empty line if it's not generated by hard line break
    pos.clean(pos.end());
    return true;
  }
  auto ellipsis = createEllipsis(pos);
  fLines.emplace_back(
      fCurrentLineOffset,
      SkVector::Make(pos.trimmedWidth(), pos.height()),
      respectBidi(fLineCharStart, pos),
      ellipsis,
      pos.sizes());
  if (true) {
    auto& line = fLines.back();
    SkDebugf("addLine %F '%s'\n", fCurrentLineOffset.fX, toString(line.text()).c_str());
  }
  fWidth =  SkMaxScalar(fWidth, pos.trimmedWidth());
  fHeight += pos.height();

  // Eat up all the whitespaces and set the start to the next line
  fLineGlyphStart = pos.end() + 1;
  if (!pos.end()->isHardBreak()) {
    while (fLineGlyphStart < fClusters.end() &&
        fLineGlyphStart->isWhitespaces()) { ++fLineGlyphStart; }
  }
  fLineCharStart = fLineGlyphStart;
  fCurrentLineOffset.fY += pos.height();
  if (fLineGlyphStart < fClusters.end()) {
    // Shift the rest of the line horizontally to the left
    // to compensate for the run positions since we broke the line
    fCurrentLineOffset.fX = - fLineGlyphStart->fRun->position(fLineGlyphStart->fStart).fX;
  }
  pos.clean(fLineGlyphStart);
  return !reachedLinesLimit(0);
}

void SkTextWrapper::iterateThroughClustersByText(std::function<bool(const SkCluster&)> apply) {

  std::stack<SkCluster*> clusters;
  SkCluster* previous = nullptr;
  for (auto& cluster : fClusters) {
    if (previous != nullptr && previous->fText.end() != cluster.fText.begin()) {
      clusters.push(&cluster);
      continue;
    }

    apply(cluster);
    previous = &cluster;

    while (!clusters.empty() && previous->fText.end() == clusters.top()->fText.begin()) {
      apply(*clusters.top());
      previous = clusters.top();
      clusters.pop();
    }
  }
  SkASSERT(clusters.empty());
}

void SkTextWrapper::formatText(SkSpan<SkCluster> clusters,
                               SkScalar maxWidth,
                               size_t maxLines,
                               const std::string& ellipsis) {
  fClusters = clusters;
  fMaxWidth = maxWidth;
  fMaxLines = maxLines;
  fEllipsis = ellipsis;
  fLineGlyphStart = fClusters.begin();
  fLineCharStart = fClusters.begin();
  fClosestBreak.clean(fLineGlyphStart);
  fAfterBreak.clean(fLineGlyphStart);
  fCurrentLineOffset = SkVector::Make(0, 0);
  fWidth = 0;
  fHeight = 0;
  fMinIntrinsicWidth = 0;

  SkScalar wordLength = 0;
  // Iterate through all the clusters by the TEXT order (ignoring bidi)
  iterateThroughClustersByText([&](const SkCluster& cluster) {
    if (!cluster.isWhitespaces()) {
      //SkDebugf("'%s'\n", toString(cluster.fText).c_str());
      //SkDebugf("WIDTHS: %f %f %f %f\n", cluster.fWidth, fAfterBreak.width(), fClosestBreak.width(), wordLength);
      wordLength += cluster.fWidth;
      if (fClosestBreak.width() + fAfterBreak.width() + cluster.fWidth > fMaxWidth) {
        // Cluster does not fit: add the line until the closest break
        if (!addLine(fClosestBreak))  return false;
      }
      if (fAfterBreak.width() + cluster.fWidth > fMaxWidth) {
        // Cluster does not fit yet: try to break the text by hyphen
        // TODO: This is the place where we add the hypenation logic
      }

      if (fAfterBreak.width() + cluster.fWidth > fMaxWidth) {
        // Cluster does not fit yet: add the line with the rest of clusters
        SkASSERT(fClosestBreak.width() == 0);
        fClosestBreak.add(fAfterBreak);
        if (!addLine(fClosestBreak))  return false;
      }
      if (cluster.fWidth > fMaxWidth) {
        //  Cluster still does not fit: it's too long; let's clip it
        fClosestBreak.add(cluster);
        if (!addLine(fClosestBreak))  return false;
        return true;
      }
    } else {
      fMinIntrinsicWidth = SkTMax(fMinIntrinsicWidth, wordLength);
      wordLength = 0;
    }
    // The cluster fits the line
    fAfterBreak.add(cluster);
    // Update the lineCharStart with respect to bidi
    if (fLineCharStart->fText.begin() > cluster.fText.begin()) {
      fLineCharStart = &cluster;
    }

    if (cluster.canBreakLineAfter()) {
      fClosestBreak.add(fAfterBreak);
    }
    if (cluster.isHardBreak()) {
      // Hard line break
      if (!addLine(fClosestBreak))  return false;
    }

    return true;
  });

  // Make sure nothing left
  if (!endOfText() && !reachedLinesLimit(0)) {
    fMinIntrinsicWidth = SkTMax(fMinIntrinsicWidth, wordLength);
    fClosestBreak.add(fAfterBreak);
    addLine(fClosestBreak);
  }
}

SkRun* SkTextWrapper::getEllipsis(SkRun* run) {
  SkRun* found = fEllipsisCache.find(run->font());
  if (found != nullptr) {
    return found;
  }
  found = shapeEllipsis(run);
  return found;
}

SkRun* SkTextWrapper::shapeEllipsis(SkRun* run) {

  class ShapeHandler final : public SkShaper::RunHandler {

   public:
    ShapeHandler(SkTextWrapper* master) : fMaster(master), fRun(nullptr) { }
    SkRun* run() { return fRun; }

   private:

    void beginLine() override { }

    void runInfo(const RunInfo&) override { }

    void commitRunInfo() override { }

    Buffer runBuffer(const RunInfo& info) override {

      fRun = fMaster->fEllipsisCache.set(info.fFont, SkRun(info, 0, 0));
      return fRun->newRunBuffer();
    }

    void commitRunBuffer(const RunInfo&) override { }

    void commitLine() override { }

    SkTextWrapper* fMaster;
    SkRun* fRun;
  };

  ShapeHandler handler(this);
  std::unique_ptr<SkShaper> shaper = SkShaper::MakeShapeThenWrap();
  shaper->shape(fEllipsis.data(), fEllipsis.size(),
                run->font(),
                true,
                std::numeric_limits<SkScalar>::max(),
                &handler);

  return handler.run();
}
